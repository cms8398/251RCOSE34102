//기본 c 라이브러리
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//프로세스, 스케줄링 결과 평가함수, cpu의 헤더파일
#include "process.h"
#include "evaluation.h"
#include "cpu.h"
#include "scheduler_type.h"
#include "gantt.h"

//fcfs스케줄링 알고리즘 헤더파일
#include "fcfs.h"
#include "ready_queue.h"

//sjf스케줄링 알고리즘 헤더파일
#include "sjf.h"
#include "heap.h" 

//priority 스케줄링 알고리즘 헤더파일 -> priority가 낮을 수록 실행 우선 순위 높은 것
#include "priority.h"

int main(void)
{  
    int num_processes;
    printf("Enter the number of processes to schedule (max %d): ", MAX_PROCESSES);
    scanf("%d", &num_processes);
    Process *processes = create_process(num_processes);

    printf("Will you randomly generate the process information?/PIDs are generated by the sequence processes created(1: Yes, 0: No) : ");
    int random_choice;
    scanf("%d", &random_choice);  
    
    if(random_choice == 0) {
        for(int i = 0; i < num_processes; i++) {
            processes[i] = (Process){-1}; // 초기화
            printf("Enter the information for process %d:\n", i);
            processes[i].pid = i; // pid는 0부터 시작하는 순차적인 값으로 설정
            
            printf("Priority: ");
            scanf("%d", &processes[i].priority);
            getchar(); // 버퍼 비우기
            
            printf("CPU Burst: ");
            scanf("%d", &processes[i].CPU_burst);
            getchar(); // 버퍼 비우기
            
            printf("Arrival Time: ");
            scanf("%d", &processes[i].arrival_time);
            getchar(); // 버퍼 비우기

            processes[i].remaining_time = processes[i].CPU_burst; // remaining time은 CPU burst와 같음
            processes[i].state = NEW; // 초기 상태는 NEW
        }
    } 
    else {
        srand(time(NULL)); // 랜덤 시드 초기화
        for(int i = 0; i < num_processes; i++) {
        process_init(&processes[i], i); //process들을 초기화, pid의 경우 중복됨을 피하고, 편리하도록 생성되는 순서를 사용.
        }
    }
    
    //생성된 process들의 정보를 출력
    for(int i = 0; i < num_processes; i++) {
        print_process(processes+i); 
    }
    
    SchedulerType type;
    int input;
    getchar(); // 버퍼 비우기
    printf("Choose the scheduling algorithm: ");
    scanf("%d",&input);
    type = (SchedulerType)input; //사용자가 입력한 스케줄링 알고리즘을 enum으로 변환
    switch (type)
    {
        case fcfs:
            FCFS(processes, num_processes); //fcfs 알고리즘을 사용한 스케줄링
            printf("Scheduling completed\n");
            print_average_performance(processes, num_processes);
            print_each_performance(processes, num_processes);
            simple_gantt(processes, num_processes); //fcfs 알고리즘을 사용한 간트차트 출력
            break;
       
        case sjf:
            SJF(processes, num_processes); //sjf 알고리즘을 사용한 스케줄링
            printf("Scheduling completed\n");
            print_average_performance(processes, num_processes);
            print_each_performance(processes, num_processes);
            simple_gantt(processes, num_processes); //sjf 알고리즘을 사용한 간트차트 출력
            break;
        
        case priority:
            Priority(processes, num_processes); //priority 알고리즘을 사용한 스케줄링
            printf("Scheduling completed\n");
            print_average_performance(processes, num_processes);
            print_each_performance(processes, num_processes);
            simple_gantt(processes, num_processes); //priority 알고리즘을 사용한 간트차트 출력
            break;

        default:
            printf("Invalid choice\n Terminating the process\n");
            delete_processes(processes);
            exit(-1);
            break;
    }


    delete_processes(processes); // process들에게 할당된 메모리 제거하기
   
    return 0;
}